var documenterSearchIndex = {"docs":
[{"location":"man/kroneckerpowers/#Kronecker-powers-and-graphs","page":"Kronecker powers and graphs","title":"Kronecker powers and graphs","text":"","category":"section"},{"location":"man/kroneckerpowers/#Kronecker-powers","page":"Kronecker powers and graphs","title":"Kronecker powers","text":"","category":"section"},{"location":"man/kroneckerpowers/","page":"Kronecker powers and graphs","title":"Kronecker powers and graphs","text":"Repeated Kronecker multiplications of the same matrix, i.e.","category":"page"},{"location":"man/kroneckerpowers/","page":"Kronecker powers and graphs","title":"Kronecker powers and graphs","text":"A^otimes n=otimes_i=1^n A = underbraceA otimes A otimes ldots otimes A_ntext times","category":"page"},{"location":"man/kroneckerpowers/","page":"Kronecker powers and graphs","title":"Kronecker powers and graphs","text":"Kronecker powers are supported using kronecker(A, n) or, equivalently, ⊗(A, n). These functions yield an instance of KroneckerPower, as struct which holds the matrix and the power. It works just like instances of KroneckerProduct, but more efficient since only a single matrix has to be stored and manipulated. These products work as expected.","category":"page"},{"location":"man/kroneckerpowers/","page":"Kronecker powers and graphs","title":"Kronecker powers and graphs","text":"using Kronecker\nA = rand(2, 2)\nK2 = A ⊗ 2\ninv(K2)\nK12 = K2 ⊗ 6  # works recursively\nK12^2  # example","category":"page"},{"location":"man/kroneckerpowers/","page":"Kronecker powers and graphs","title":"Kronecker powers and graphs","text":"kronecker(A::AbstractMatrix, pow::Int)\n⊗(A::AbstractMatrix, pow::Int)","category":"page"},{"location":"man/kroneckerpowers/#Kronecker.kronecker-Tuple{AbstractArray{T,2} where T,Int64}","page":"Kronecker powers and graphs","title":"Kronecker.kronecker","text":"kronecker(A::AbstractMatrix, pow::Int)\n\nKronecker power, computes A ⊗ A ⊗ ... ⊗ A. Returns a lazy KroneckerPower type.\n\n\n\n\n\n","category":"method"},{"location":"man/kroneckerpowers/#Kronecker.:⊗-Tuple{AbstractArray{T,2} where T,Int64}","page":"Kronecker powers and graphs","title":"Kronecker.:⊗","text":"⊗(A::AbstractMatrix, pow::Int)\n\nKronecker power, computes A ⊗ A ⊗ ... ⊗ A. Returns a lazy KroneckerPower type.\n\n\n\n\n\n","category":"method"},{"location":"man/kroneckerpowers/#Kronecker-graphs","page":"Kronecker powers and graphs","title":"Kronecker graphs","text":"","category":"section"},{"location":"man/kroneckerpowers/","page":"Kronecker powers and graphs","title":"Kronecker powers and graphs","text":"An exciting application of Kronecker powers (or Krocker products in general) is generating large, realistic graphs from an initial 'seed' via a stochastic process. This is called a Kronecker graph and is described in detail in Leskovec et al. (2008).","category":"page"},{"location":"man/kroneckerpowers/","page":"Kronecker powers and graphs","title":"Kronecker powers and graphs","text":"If we use an initial matrix P with values in 01 as a seed, then P_n=P^otimes n can be seen as a probability distribution for an adjacency matrix of a graph. The elements (P_n)_ij give the probabilities that there is an edge from node i to node j. Leskovec and co-authors give two algorithms for sampling adjacency matrices from this distribution, both provided by Kronecker.jl:","category":"page"},{"location":"man/kroneckerpowers/","page":"Kronecker powers and graphs","title":"Kronecker powers and graphs","text":"naivesample gives exact samples, but has a computational time proportional to the number of elements and hence prohibitive for large graphs;\nfastsample a recursive heuristic, has a computational time proportional to the expected number of edges in the graph.","category":"page"},{"location":"man/kroneckerpowers/","page":"Kronecker powers and graphs","title":"Kronecker powers and graphs","text":"The latter can easily scale to generate graphs of millions of nodes. Both return the adjacency matrix as a sparse array.","category":"page"},{"location":"man/kroneckerpowers/","page":"Kronecker powers and graphs","title":"Kronecker powers and graphs","text":"using Kronecker\nP = rand(2, 2)\nP10 = P ⊗ 10\nsum(P10)  # expected number of edges\nA = fastsample(P10)","category":"page"},{"location":"man/kroneckerpowers/","page":"Kronecker powers and graphs","title":"Kronecker powers and graphs","text":"isprob\nnaivesample\nfastsample","category":"page"},{"location":"man/kroneckerpowers/#Kronecker.isprob","page":"Kronecker powers and graphs","title":"Kronecker.isprob","text":"isprob(A::AbstractArray)\n\nTest if a matrix can be interpeted as a probability matrix, i.e., all elements are between 0 and 1.\n\n\n\n\n\nisprob(K::AbstractKroneckerProduct)\n\nTest if a Kronecker product can be interpeted as a probability matrix, i.e., all elements are between 0 and 1.\n\n\n\n\n\n","category":"function"},{"location":"man/kroneckerpowers/#Kronecker.naivesample","page":"Kronecker powers and graphs","title":"Kronecker.naivesample","text":"naivesample(P::AbstractKroneckerProduct)\n\nSample a Kronecker graph from a probabilistic Kronecker product P using the naive method. This method has a time complexity in the size of the Kronecker product (but is still light in memory use). Consider using fastsample.\n\n\n\n\n\n","category":"function"},{"location":"man/kroneckerpowers/#Kronecker.fastsample","page":"Kronecker powers and graphs","title":"Kronecker.fastsample","text":"fastsample(P::AbstractKroneckerProduct)\n\nUses the heuristic sampling from Leskovec et al. (2008) to sample a large Kronecker graph.\n\n\n\n\n\n","category":"function"},{"location":"man/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"The abstract type at the top of the hierarchy of Kronecker.jl's type system is GeneralizedKroneckerProduct a subtype AbstractMatrix. GeneralizedKroneckerProduct contains all subtypes which contain a Kronecker product.","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"Pure Kronecker products, i.e., all expressions that one can write as A ⊗ B, with A and B AbstractMatix types are part of the abstract type AbstractKroneckerProduct <: GeneralizedKroneckerProduct. Concrete instantiations are stored in the structure KroneckerProduct <: AbstractKroneckerProduct, a container for A and B. Instances of KroneckerProduct structs are annotated with the element type of the Kronecker product (promoted from the element types of A and B) and the types of A and B.","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"For Kronecker powers, iterative multiplications of the same matrix, i.e.,","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"bigotimes_i=1^K A = Aotimes A otimes ldots otimes A","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"are stored in the structure KroneckerPower <: AbstractKroneckerProduct. This is more efficient, as it only processes a single matrix, irregardless of the order of the product.","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"Special cases are KroneckerSum <: AbstractKroneckerSum <: GeneralizedKroneckerProduct for the Kronecker sum:","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"A oplus B = A otimes I + I otimes B","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"These work similar to instances of AbstractKroneckerProduct.","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"Finally, we have IndexedKroneckerProduct <: GeneralizedKroneckerProduct, which stores submatrices of a Kronecker product. This contains both the Kronecker product as well as the indices.","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"It is important to note that since all instances of subtypes of GeneralizedKroneckerProduct are instances of an AbstractMatrix, it is possible to combine them at heart. This is because Kronecker products are between any types of matrices, which Kronecker products themselves are.","category":"page"},{"location":"man/multiplication/#Multiplication","page":"Multiplication","title":"Multiplication","text":"","category":"section"},{"location":"man/multiplication/","page":"Multiplication","title":"Multiplication","text":"Kronecker.jl allows for efficient multiplication of large Kronecker systems by overloading the multiplication function *. We distinguish three cases:","category":"page"},{"location":"man/multiplication/","page":"Multiplication","title":"Multiplication","text":"Kronecker-Kronecker multiplications yield again a type of AbstractKroneckerProduct;\nKronecker-vector multiplications use the 'vec trick' and yield a vector;\nsampled Kronecker-vector multiplications use the sampled-vec trick to yield a vector.","category":"page"},{"location":"man/multiplication/#Kronecker-kronecker-multiplications","page":"Multiplication","title":"Kronecker-kronecker multiplications","text":"","category":"section"},{"location":"man/multiplication/","page":"Multiplication","title":"Multiplication","text":"Multiplying two conformable Kronecker products of the same order yield a new Kronecker product, based on the mixed-product property:","category":"page"},{"location":"man/multiplication/","page":"Multiplication","title":"Multiplication","text":"(A otimes B)(C otimes D) = (AC) otimes (BD)","category":"page"},{"location":"man/multiplication/","page":"Multiplication","title":"Multiplication","text":"using Kronecker # hide\nA, B, C, D = randn(5, 5), randn(4, 4), randn(5, 4), randn(4, 4);\n(A ⊗ B) * (C ⊗ D)","category":"page"},{"location":"man/multiplication/#The-Vec-trick","page":"Multiplication","title":"The Vec trick","text":"","category":"section"},{"location":"man/multiplication/","page":"Multiplication","title":"Multiplication","text":"Reshaping allows computing a product between a Kronecker product and vector as two matrix multiplications. This is the so-called vec trick which holds for any set of conformable matrices:","category":"page"},{"location":"man/multiplication/","page":"Multiplication","title":"Multiplication","text":"(A otimes B) textvec(X) = textvec(B^intercal X A)","category":"page"},{"location":"man/multiplication/","page":"Multiplication","title":"Multiplication","text":"Here, textvec(cdot) is the vectorization operator, which stacks all columns of a matrix into a vector.","category":"page"},{"location":"man/multiplication/","page":"Multiplication","title":"Multiplication","text":"using Kronecker # hide\nA, B = rand(10, 10), rand(5, 6);\nx = randn(60);\n(A ⊗ B) * x","category":"page"},{"location":"man/multiplication/","page":"Multiplication","title":"Multiplication","text":"Note that this trick is extended to also work with matrices:","category":"page"},{"location":"man/multiplication/","page":"Multiplication","title":"Multiplication","text":"using Kronecker # hide\nA, B = rand(10, 10), rand(5, 6);\nx = randn(60, 2);\n(A ⊗ B) * x","category":"page"},{"location":"man/multiplication/","page":"Multiplication","title":"Multiplication","text":"The vec trick works with higher-order Kronecker products. However, at the moment this has a substantial overhead and likely be relatively slow.","category":"page"},{"location":"man/multiplication/#Docstrings","page":"Multiplication","title":"Docstrings","text":"","category":"section"},{"location":"man/multiplication/","page":"Multiplication","title":"Multiplication","text":"mul!\nlmul!\nrmul!","category":"page"},{"location":"man/multiplication/#LinearAlgebra.lmul!","page":"Multiplication","title":"LinearAlgebra.lmul!","text":"lmul!(a::Number, K::AbstractKroneckerProduct)\n\nScale an AbstractKroneckerProduct K inplace by a factor a by rescaling the left matrix.\n\n\n\n\n\nlmul!(a::Number, K::KroneckerPower)\n\nScale an KroneckerPower K inplace by a factor a by rescaling the matrix the base matrix with a factor a^(1/N).\n\nIt is recommended to rewrite your Kronecker product rather as copy(A) ⊗ (A ⊗ n - 1) (note the copy) for numerical stability. This will only modify the first matrix, leaving the chain of Kronecker products alone.\n\n\n\n\n\n","category":"function"},{"location":"man/multiplication/#LinearAlgebra.rmul!","page":"Multiplication","title":"LinearAlgebra.rmul!","text":"rmul!(K::AbstractKroneckerProduct, a::Number)\n\nScale an AbstractKroneckerProduct K inplace by a factor a by rescaling the right matrix.\n\n\n\n\n\n","category":"function"},{"location":"man/multiplication/#Sampled-Kronecker-vector-multiplications","page":"Multiplication","title":"Sampled Kronecker-vector multiplications","text":"","category":"section"},{"location":"man/multiplication/","page":"Multiplication","title":"Multiplication","text":"See Indexed Kronecker products for the specifics.","category":"page"},{"location":"man/kroneckersums/#Kronecker-sums","page":"Kronecker sums","title":"Kronecker sums","text":"","category":"section"},{"location":"man/kroneckersums/","page":"Kronecker sums","title":"Kronecker sums","text":"A Kronecker sum between two square matrices of the same size is defined as","category":"page"},{"location":"man/kroneckersums/","page":"Kronecker sums","title":"Kronecker sums","text":"A oplus B = A  I + I oplus B","category":"page"},{"location":"man/kroneckersums/","page":"Kronecker sums","title":"Kronecker sums","text":"To construct objects of the KroneckerSum type, one can either use kroneckersum or the binary operator ⊕. Lazy Kronecker sums work like lazy Kronecker products, though there are far fewer methods to process these constructs efficiently. The most important property for Kronecker sums relates to matrix exponentiation:","category":"page"},{"location":"man/kroneckersums/","page":"Kronecker sums","title":"Kronecker sums","text":"exp(A oplus B) = exp(A) otimes exp(B)","category":"page"},{"location":"man/kroneckersums/","page":"Kronecker sums","title":"Kronecker sums","text":"The function collect can be used to transform a KroneckerSum struct into a sparse array. It is recommended to make it 'dense' this way before doing operations such as multiplication with a vector.","category":"page"},{"location":"man/kroneckersums/","page":"Kronecker sums","title":"Kronecker sums","text":"using Kronecker # hide\nA, B = rand(Bool, 5, 5), rand(4, 4);\nK = A ⊕ B\nexp(K)\ncollect(K)","category":"page"},{"location":"man/kroneckersums/","page":"Kronecker sums","title":"Kronecker sums","text":"kroneckersum\n⊕\ncollect(K::AbstractKroneckerSum)\nexp\nmul!(x::AbstractVector, K::AbstractKroneckerSum, v::AbstractVector)","category":"page"},{"location":"man/kroneckersums/#Kronecker.kroneckersum","page":"Kronecker sums","title":"Kronecker.kroneckersum","text":"kroneckersum(A::AbstractMatrix, B::AbstractMatrix)\n\nConstruct a sum of Kronecker products between two square matrices and their respective identity matrices. Does not evaluate the Kronecker products explicitly.\n\n\n\n\n\nkroneckersum(A::AbstractMatrix, B::AbstractMatrix...)\n\nHigher-order lazy kronecker sum, e.g.\n\nkroneckersum(A,B,C,D)\n\n\n\n\n\nkroneckersum(A::AbstractMatrix, pow::Int)\n\nKronecker-sum power, computes A ⊕ A ⊕ ... ⊕ A = (A ⊗ I ⊗ ... ⊗ I) + (I ⊗ A ⊗ ... ⊗ I) + ... (I ⊗ I ⊗ ... A).\n\n\n\n\n\n","category":"function"},{"location":"man/kroneckersums/#Kronecker.:⊕","page":"Kronecker sums","title":"Kronecker.:⊕","text":"⊕(A::AbstractMatrix, B::AbstractMatrix)\n\nBinary operator for kroneckersum, computes as Lazy Kronecker sum. See kroneckersum for documentation.\n\n\n\n\n\n","category":"function"},{"location":"man/kroneckersums/#Base.collect-Tuple{AbstractKroneckerSum}","page":"Kronecker sums","title":"Base.collect","text":"collect(K::AbstractKroneckerSum)\n\nCollects a lazy instance of the AbstractKroneckerSum type into a full, native matrix. Returns the result as a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/kroneckersums/#Base.exp","page":"Kronecker sums","title":"Base.exp","text":"exp(K::AbstractKroneckerSum)\n\nComputes the matrix exponential of an AbstractKroneckerSum K. Returns an instance of KroneckerProduct.\n\n\n\n\n\n","category":"function"},{"location":"man/indexed/#Indexed-Kronecker-products","page":"Indexed Kronecker products","title":"Indexed Kronecker products","text":"","category":"section"},{"location":"man/indexed/","page":"Indexed Kronecker products","title":"Indexed Kronecker products","text":"To be completed...","category":"page"},{"location":"#Kronecker.jl","page":"Kronecker.jl","title":"Kronecker.jl","text":"","category":"section"},{"location":"","page":"Kronecker.jl","title":"Kronecker.jl","text":"A general-purpose toolbox for efficient Kronecker-based algebra.","category":"page"},{"location":"","page":"Kronecker.jl","title":"Kronecker.jl","text":"Kronecker.jl is a Julia package for working with large-scale Kronecker systems. The main feature of Kronecker.jl is providing a function kronecker(A, B) used to obtain an instance of the lazy GeneralizedKroneckerProduct type. In contrast to the native Julia function kron(A, B), this does not compute the Kronecker product but instead stores the matrices in a specialized structure.","category":"page"},{"location":"","page":"Kronecker.jl","title":"Kronecker.jl","text":"Commonly-used mathematical functions are overloaded to provide the most efficient methods to work with Kronecker products. We also provide an equivalent binary operator ⊗ which can be used directly as a Kronecker product in statements, i.e., A ⊗ B.","category":"page"},{"location":"","page":"Kronecker.jl","title":"Kronecker.jl","text":"Pages = [\n    \"man/basic.md\",\n    \"man/types.md\",\n    \"man/multiplication.md\"\n    \"man/factorization.md\",\n    \"man/indexed.md\",\n    \"man/kroneckersums.md\",\n    \"man/kroneckerpowers.md\"\n]","category":"page"},{"location":"#Package-features","page":"Kronecker.jl","title":"Package features","text":"","category":"section"},{"location":"","page":"Kronecker.jl","title":"Kronecker.jl","text":"tr, det, size, eltype, inv, ... are efficient functions to work with Kronecker products. Either the result is a numeric value, or returns a new KroneckerProduct type.\nKronecker product - vector multiplications are performed using the vec trick. Two Kronecker products of conformable size can be multiplied efficiently, yielding another Kronecker product.\nWorking with incomplete systems using the sampled vec trick.\nOverloading of the function eigen to compute eigenvalue decompositions of Kronecker products. It can be used to efficiently solve systems of the form (A ⊗ B +λI) \\ v.\nHigher-order Kronecker systems are supported: most functions work on A ⊗ B ⊗ C or systems of arbitrary order.\nEfficient sampling of Kronecker graphs is supported.\nKronecker powers are supported: kronecker(A, 3) or A ⊗ 3.\nA KroneckerSum can be constructed with A ⊕ B (typed using \\oplus TAB) or kroneckersum(A,B).\nMultiplication with vectors uses  a specialized version of the vec trick\nHigher-order sums are supported, e.g. A ⊕ B ⊕ C or kroneckersum(A,4).","category":"page"},{"location":"#Example-use","page":"Kronecker.jl","title":"Example use","text":"","category":"section"},{"location":"","page":"Kronecker.jl","title":"Kronecker.jl","text":"using Kronecker, LinearAlgebra\n\nA = [1.0 2.0;\n     3.0 5.0];\nB = Array{Float64, 2}([1 2 3;\n            4 5 6;\n            7 -2 9]);\n\nK = A ⊗ B\n\ncollect(K)  # yield the dense matrix\n\ntr(K)\n\ndet(K)\n\nK'  # (conjugate transpose)\n\ninv(K')\n\nK * K  # (A * A) ⊗ (B * B)\n\nv = collect(1:6)\n\nK * v","category":"page"},{"location":"man/basic/#Basic-use","page":"Basic use","title":"Basic use","text":"","category":"section"},{"location":"man/basic/","page":"Basic use","title":"Basic use","text":"Compute a lazy Kronecker products between two matrices A and B by either","category":"page"},{"location":"man/basic/","page":"Basic use","title":"Basic use","text":"K = kronecker(A, B)","category":"page"},{"location":"man/basic/","page":"Basic use","title":"Basic use","text":"or, by using the binary operator:","category":"page"},{"location":"man/basic/","page":"Basic use","title":"Basic use","text":"K = A ⊗ B","category":"page"},{"location":"man/basic/","page":"Basic use","title":"Basic use","text":"Note, ⊗ can be formed by typing \\otimes<tab>.","category":"page"},{"location":"man/basic/","page":"Basic use","title":"Basic use","text":"The Kronecker product K behaves like a matrix, for which size(K), eltype(K) works as one would expect. Elements can be accessed via K[i,j]; every element is computed on the fly. The function collect can be used to turn K in a regular, dense matrix.","category":"page"},{"location":"man/basic/","page":"Basic use","title":"Basic use","text":"using Kronecker\nA = randn(4, 4)\nB = rand(1:10, 5, 7)\nK = A ⊗ B\nK[4, 5]\neltype(K)  # promotion\ncollect(K)","category":"page"},{"location":"man/basic/#Constructing-Kronecker-products","page":"Basic use","title":"Constructing Kronecker products","text":"","category":"section"},{"location":"man/basic/","page":"Basic use","title":"Basic use","text":"kronecker\n⊗\ncollect(::AbstractKroneckerProduct)","category":"page"},{"location":"man/basic/#Kronecker.kronecker","page":"Basic use","title":"Kronecker.kronecker","text":"kronecker(A::AbstractMatrix, B::AbstractMatrix)\n\nConstruct a Kronecker product object between two arrays. Does not evaluate the Kronecker product explictly.\n\n\n\n\n\nkronecker(A::AbstractMatrix, B::AbstractMatrix)\n\nHigher-order Kronecker lazy kronecker product, e.g.\n\nkronecker(A, B, C, D)\n\n\n\n\n\nkronecker(A::AbstractMatrix, pow::Int)\n\nKronecker power, computes A ⊗ A ⊗ ... ⊗ A. Returns a lazy KroneckerPower type.\n\n\n\n\n\n","category":"function"},{"location":"man/basic/#Kronecker.:⊗","page":"Basic use","title":"Kronecker.:⊗","text":"⊗(A::AbstractMatrix, B::AbstractMatrix)\n\nBinary operator for kronecker, computes as Lazy Kronecker product. See kronecker for documentation.\n\n\n\n\n\n⊗(A::AbstractMatrix, pow::Int)\n\nKronecker power, computes A ⊗ A ⊗ ... ⊗ A. Returns a lazy KroneckerPower type.\n\n\n\n\n\n","category":"function"},{"location":"man/basic/#Base.collect-Tuple{AbstractKroneckerProduct}","page":"Basic use","title":"Base.collect","text":"collect(K::GeneralizedKroneckerProduct)\n\nCollects a lazy instance of the GeneralizedKroneckerProduct type into a dense, native matrix. Falls back to the element-wise case when not specialized method is defined.\n\n\n\n\n\n","category":"method"},{"location":"man/basic/#Basic-properties-of-Kronecker-products","page":"Basic use","title":"Basic properties of Kronecker products","text":"","category":"section"},{"location":"man/basic/","page":"Basic use","title":"Basic use","text":"getindex\neltype\nsize(::AbstractKroneckerProduct)\ncollect\ncollect!\norder\ngetmatrices\nissquare\nissymmetric\nsum","category":"page"},{"location":"man/basic/#Base.getindex","page":"Basic use","title":"Base.getindex","text":"getindex(K::AbstractKroneckerProduct, i1::Integer, i2::Integer)\n\nComputes and returns the (i,j)-th element of an AbstractKroneckerProduct K. Uses recursion if K is of an order greater than two.\n\n\n\n\n\n","category":"function"},{"location":"man/basic/#Base.size-Tuple{AbstractKroneckerProduct}","page":"Basic use","title":"Base.size","text":"size(K::AbstractKroneckerProduct)\n\nReturns a the size of an AbstractKroneckerProduct instance.\n\n\n\n\n\n","category":"method"},{"location":"man/basic/#Base.collect","page":"Basic use","title":"Base.collect","text":"collect(K::GeneralizedKroneckerProduct)\n\nCollects a lazy instance of the GeneralizedKroneckerProduct type into a dense, native matrix. Falls back to the element-wise case when not specialized method is defined.\n\n\n\n\n\ncollect(K::AbstractKroneckerSum)\n\nCollects a lazy instance of the AbstractKroneckerSum type into a full, native matrix. Returns the result as a sparse matrix.\n\n\n\n\n\nfunction collect(E::Eigen{<:Number, <:Number, <:AbstractKroneckerProduct})\n\nCollects eigenvalue decomposition of a AbstractKroneckerProduct type into a matrix.\n\n\n\n\n\n","category":"function"},{"location":"man/basic/#Kronecker.collect!","page":"Basic use","title":"Kronecker.collect!","text":"collect!(C::AbstractMatrix, K::GeneralizedKroneckerProduct)\n\nIn-place collection of K in C. If possible, specialized routines are used to speed up the computation. The fallback is an element-wise iteration. In this case, this function might be slow.\n\n\n\n\n\ncollect!(C::AbstractMatrix, K::AbstractKroneckerProduct)\n\nIn-place collection of K in C where K is an AbstractKroneckerProduct, i.e., K = A ⊗ B. This is equivalent to the broadcasted assignment C .= K.\n\ncollect!(f, C::AbstractMatrix, K1::AbstractKroneckerProduct, Ks::AbstractKroneckerProduct...)\n\nEvaluate f.(K1, Ks...) and assign it in-place to C. This is equivalent to the broadcasted operation C .= f.(K1, Ks...).\n\n\n\n\n\ncollect!(C::AbstractMatrix, K::AbstractKroneckerSum)\n\nIn-place collection of K in C where K is an AbstractKroneckerSum, i.e., K = A ⊗ B.\n\n\n\n\n\n","category":"function"},{"location":"man/basic/#Kronecker.order","page":"Basic use","title":"Kronecker.order","text":"order(M::AbstractMatrix)\n\nReturns the order of a matrix, i.e. how many matrices are involved in the Kronecker product (default to 1 for general matrices).\n\n\n\n\n\n","category":"function"},{"location":"man/basic/#Kronecker.getmatrices","page":"Basic use","title":"Kronecker.getmatrices","text":"getmatrices(K::AbstractKroneckerProduct)\n\nObtain the two matrices of an AbstractKroneckerProduct object.\n\n\n\n\n\ngetmatrices(A::AbstractArray)\n\nReturns a matrix itself. Needed for recursion.\n\n\n\n\n\ngetmatrices(K::T) where T <: AbstractKroneckerSum\n\nObtain the two matrices of an AbstractKroneckerSum object.\n\n\n\n\n\n","category":"function"},{"location":"man/basic/#Kronecker.issquare","page":"Basic use","title":"Kronecker.issquare","text":"issquare(A::AbstractMatrix)\n\nChecks if an array is a square matrix.\n\n\n\n\n\nissquare(A::Factorization)\n\nChecks if a Factorization struct represents a square matrix.\n\n\n\n\n\n","category":"function"},{"location":"man/basic/#LinearAlgebra.issymmetric","page":"Basic use","title":"LinearAlgebra.issymmetric","text":"issymmetric(K::AbstractKroneckerProduct)\n\nChecks if a Kronecker product is symmetric.\n\n\n\n\n\n","category":"function"},{"location":"man/basic/#Linear-algebra","page":"Basic use","title":"Linear algebra","text":"","category":"section"},{"location":"man/basic/","page":"Basic use","title":"Basic use","text":"Many functions of the LinearAlgebra module are overloaded to work with subtypes of GeneralizedKroneckerProduct.","category":"page"},{"location":"man/basic/","page":"Basic use","title":"Basic use","text":"det(K::AbstractKroneckerProduct)\nlogdet(K::AbstractKroneckerProduct)\ntr(K::AbstractKroneckerProduct)\ninv(K::AbstractKroneckerProduct)\nadjoint(K::AbstractKroneckerProduct)\ntranspose(K::AbstractKroneckerProduct)\nconj(K::AbstractKroneckerProduct)","category":"page"},{"location":"man/basic/#LinearAlgebra.det-Tuple{AbstractKroneckerProduct}","page":"Basic use","title":"LinearAlgebra.det","text":"det(K::AbstractKroneckerProduct)\n\nCompute the determinant of a Kronecker product.\n\n\n\n\n\n","category":"method"},{"location":"man/basic/#LinearAlgebra.logdet-Tuple{AbstractKroneckerProduct}","page":"Basic use","title":"LinearAlgebra.logdet","text":"logdet(K::AbstractKroneckerProduct)\n\nCompute the logarithm of the determinant of a Kronecker product.\n\n\n\n\n\n","category":"method"},{"location":"man/basic/#LinearAlgebra.tr-Tuple{AbstractKroneckerProduct}","page":"Basic use","title":"LinearAlgebra.tr","text":"tr(K::AbstractKroneckerProduct)\n\nCompute the trace of a Kronecker product.\n\n\n\n\n\n","category":"method"},{"location":"man/basic/#Base.inv-Tuple{AbstractKroneckerProduct}","page":"Basic use","title":"Base.inv","text":"inv(K::AbstractKroneckerProduct)\n\nCompute the inverse of a Kronecker product.\n\n\n\n\n\n","category":"method"},{"location":"man/basic/#Base.adjoint-Tuple{AbstractKroneckerProduct}","page":"Basic use","title":"Base.adjoint","text":"adjoint(K::AbstractKroneckerProduct)\n\nCompute the adjoint of a Kronecker product.\n\n\n\n\n\n","category":"method"},{"location":"man/basic/#Base.transpose-Tuple{AbstractKroneckerProduct}","page":"Basic use","title":"Base.transpose","text":"transpose(K::AbstractKroneckerProduct)\n\nCompute the transpose of a Kronecker product.\n\n\n\n\n\n","category":"method"},{"location":"man/factorization/#Factorization-methods","page":"Factorization methods","title":"Factorization methods","text":"","category":"section"},{"location":"man/factorization/","page":"Factorization methods","title":"Factorization methods","text":"Many forms of matrix factorization such as eigenvalue decomposition, LU factorization, Cholesky factorization etc., can be computed efficiently. The decomposition of the Kronecker product is the Kronecker product of the decompositions. We have overloaded some of the factorization functions from LinearAlgebra to compute the factorization of instances of AbstractKroneckerProduct.","category":"page"},{"location":"man/factorization/#Eigenvalue-decomposition","page":"Factorization methods","title":"Eigenvalue decomposition","text":"","category":"section"},{"location":"man/factorization/","page":"Factorization methods","title":"Factorization methods","text":"The function eigen of LinearAlgebra is overloaded to compute the decomposition of AbstractKroneckerProducts. The result is a factorization of the Eigen type, containing a vector of the eigenvalues and a matrix with the eigenvectors. Just like long-time users would expect! The eigenvectors are structured as Kronecker products and can be processed accordingly.","category":"page"},{"location":"man/factorization/","page":"Factorization methods","title":"Factorization methods","text":"The functions det, logdet, inv and \\ are overloaded the make use of this decomposition.","category":"page"},{"location":"man/factorization/","page":"Factorization methods","title":"Factorization methods","text":"The eigenvalue decomposition of matrices can be used to solve large systems of the form:","category":"page"},{"location":"man/factorization/","page":"Factorization methods","title":"Factorization methods","text":"(A otimes B + ccdot I) mathbfx = mathbfb","category":"page"},{"location":"man/factorization/","page":"Factorization methods","title":"Factorization methods","text":"The case where A and B are positive semi-definite frequently occurs in machine learning, for example in ridge regression.","category":"page"},{"location":"man/factorization/","page":"Factorization methods","title":"Factorization methods","text":"using Kronecker, LinearAlgebra # hide\nA, B = rand(10, 10), randn(4, 4);\nAs, Bs = (A, B) .|> X -> X * X';  # make positive definite\nK = As ⊗ Bs\nE = eigen(K)\nlogdet(E)\nb = randn(40);\n(E + 0.1I) \\ b  # solve a system","category":"page"},{"location":"man/factorization/","page":"Factorization methods","title":"Factorization methods","text":"eigen\n+(E::Eigen, B::UniformScaling)\n+(::Eigen, ::UniformScaling)\n\ndet(E::Eigen{<:Number, <:Number, <:AbstractKroneckerProduct})\nlogdet(E::Eigen{<:Number, <:Number, <:AbstractKroneckerProduct})\ninv(E::Eigen{<:Number, <:Number, <:AbstractKroneckerProduct})","category":"page"},{"location":"man/factorization/#LinearAlgebra.eigen","page":"Factorization methods","title":"LinearAlgebra.eigen","text":"eigen(K::AbstractKroneckerProduct)\n\nWrapper around eigen from the LinearAlgebra package. If the matrices of an AbstractKroneckerProduct instance are square, performs Eigenvalue decompositon on them and returns an Eigen type. Otherwise, it collects the instance and runs eigen on the full matrix. The functions, \\, inv, and logdet are overloaded to efficiently work with this type.\n\n\n\n\n\n","category":"function"},{"location":"man/factorization/#LinearAlgebra.det-Tuple{Eigen{var\"#s5\",var\"#s3\",var\"#s2\",U} where U<:(AbstractArray{T,1} where T) where var\"#s2\"<:AbstractKroneckerProduct where var\"#s3\"<:Number where var\"#s5\"<:Number}","page":"Factorization methods","title":"LinearAlgebra.det","text":"det(K::AbstractKroneckerProduct)\n\nCompute the determinant of a Kronecker product.\n\n\n\n\n\n","category":"method"},{"location":"man/factorization/#LinearAlgebra.logdet-Tuple{Eigen{var\"#s5\",var\"#s3\",var\"#s2\",U} where U<:(AbstractArray{T,1} where T) where var\"#s2\"<:AbstractKroneckerProduct where var\"#s3\"<:Number where var\"#s5\"<:Number}","page":"Factorization methods","title":"LinearAlgebra.logdet","text":"logdet(K::Eigen)\n\nCompute the logarithm of the determinant of the eigenvalue decomp of aKronecker product.\n\n\n\n\n\n","category":"method"},{"location":"man/factorization/#Base.inv-Tuple{Eigen{var\"#s5\",var\"#s3\",var\"#s2\",U} where U<:(AbstractArray{T,1} where T) where var\"#s2\"<:AbstractKroneckerProduct where var\"#s3\"<:Number where var\"#s5\"<:Number}","page":"Factorization methods","title":"Base.inv","text":"inv(K::Eigen)\n\nCompute the inverse of the eigenvalue decomp of aKronecker product. Returns another type of Eigen.\n\n\n\n\n\n","category":"method"},{"location":"man/factorization/#Cholesky-factorization","page":"Factorization methods","title":"Cholesky factorization","text":"","category":"section"},{"location":"man/factorization/","page":"Factorization methods","title":"Factorization methods","text":"Similar to the eigenvalue decomposition, cholesky has been overloaded to allow for efficient Cholesky decomposition of Kronecker products of symmetric and positive definite matrices.","category":"page"},{"location":"man/factorization/","page":"Factorization methods","title":"Factorization methods","text":"using Kronecker, LinearAlgebra # hide\nA, B = rand(10, 10), randn(4, 4);\nAs, Bs = (A, B) .|> X -> X * X';  # make positive definite\nK = As ⊗ Bs\nC = cholesky(K)\nlogdet(C)\ninv(C)","category":"page"},{"location":"man/factorization/","page":"Factorization methods","title":"Factorization methods","text":"cholesky","category":"page"},{"location":"man/factorization/#LinearAlgebra.cholesky","page":"Factorization methods","title":"LinearAlgebra.cholesky","text":"cholesky(K::AbstractKroneckerProduct; check = true)\n\nWrapper around cholesky from the LinearAlgebra package. Performs Cholesky on the matrices of a AbstractKroneckerProduct instances and returns a CholeskyKronecker type. Similar to Cholesky, size, \\, inv, det, and logdet are overloaded to efficiently work with this type.\n\n\n\n\n\n","category":"function"}]
}
