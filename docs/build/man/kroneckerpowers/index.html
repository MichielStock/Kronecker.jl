<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Kronecker powers and graphs · Kronecker.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Kronecker.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Kronecker.jl</a></li><li><a class="toctext" href="../basic/">Basic use</a></li><li><a class="toctext" href="../factorization/">Factorization methods</a></li><li><a class="toctext" href="../indexed/">Indexed Kronecker products</a></li><li class="current"><a class="toctext" href>Kronecker powers and graphs</a><ul class="internal"><li><a class="toctext" href="#Kronecker-powers-1">Kronecker powers</a></li><li><a class="toctext" href="#Kronecker-graphs-1">Kronecker graphs</a></li></ul></li><li><a class="toctext" href="../kroneckersums/">Kronecker sums</a></li><li><a class="toctext" href="../multiplication/">Multiplication</a></li><li><a class="toctext" href="../types/">Types</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Kronecker powers and graphs</a></li></ul><a class="edit-page" href="https://github.com/MichielStock/Kronecker.jl/blob/master/docs/src/man/kroneckerpowers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Kronecker powers and graphs</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Kronecker-powers-and-graphs-1" href="#Kronecker-powers-and-graphs-1">Kronecker powers and graphs</a></h1><h2><a class="nav-anchor" id="Kronecker-powers-1" href="#Kronecker-powers-1">Kronecker powers</a></h2><p>Repeated Kronecker multiplications of the same matrix, i.e.</p><div>\[A^{\otimes n}=\otimes_{i=1}^n A = \underbrace{A \otimes A \otimes \ldots \otimes A}_{n\text{ times}}\,.\]</div><p>Kronecker powers are supported using <code>kronecker(A, n)</code> or, equivalently, <code>⊗(A, n)</code>. These functions yield an instance of <code>KroneckerPower</code>, as struct which holds the matrix and the power. It works just like instances of <code>KroneckerProduct</code>, but more efficient since only a single matrix has to be stored and manipulated. These products work as expected.</p><pre><code class="language-julia-repl">julia&gt; using Kronecker

julia&gt; A = rand(2, 2)
2×2 Array{Float64,2}:
 0.638382  0.860726
 0.122651  0.0493887

julia&gt; K2 = A ⊗ 2
4×4 KroneckerPower{Array{Float64,2},2}:
 0.407531   0.549471   0.549471   0.740849
 0.0782984  0.0315288  0.105569   0.0425101
 0.0782984  0.105569   0.0315288  0.0425101
 0.0150434  0.0060576  0.0060576  0.00243924

julia&gt; inv(K2)
4×4 KroneckerPower{Array{Float64,2},2}:
  0.444956   -7.75451   -7.75451   135.142
 -1.105       5.75135   19.2575   -100.232
 -1.105      19.2575     5.75135  -100.232
  2.74415   -14.2829   -14.2829     74.34

julia&gt; K12 = K2 ⊗ 6  # works recursively
4096×4096 KroneckerPower{KroneckerPower{Array{Float64,2},2},6}:
 0.00458104   0.00617658   0.00617658   …  0.122629     0.16534
 0.000880149  0.000354414  0.0011867       0.0235605    0.00948725
 0.000880149  0.0011867    0.000354414     0.00703648   0.00948725
 0.000169102  6.80932e-5   6.80932e-5      0.00135191   0.000544381
 0.000880149  0.0011867    0.0011867       0.00703648   0.00948725
 0.000169102  6.80932e-5   0.000227999  …  0.00135191   0.000544381
 0.000169102  0.000227999  6.80932e-5      0.000403756  0.000544381
 3.24894e-5   1.30827e-5   1.30827e-5      7.75731e-5   3.12367e-5
 0.000880149  0.0011867    0.0011867       0.00703648   0.00948725
 0.000169102  6.80932e-5   0.000227999     0.00135191   0.000544381
 ⋮                                      ⋱               ⋮
 6.03227e-11  2.42905e-11  2.42905e-11     9.1162e-15   3.67087e-15
 1.63417e-9   2.20334e-9   2.20334e-9      8.2691e-13   1.11492e-12
 3.1397e-10   1.26428e-10  4.23324e-10     1.58873e-13  6.39743e-14
 3.1397e-10   4.23324e-10  1.26428e-10  …  4.74484e-14  6.39743e-14
 6.03227e-11  2.42905e-11  2.42905e-11     9.1162e-15   3.67087e-15
 3.1397e-10   4.23324e-10  4.23324e-10     4.74484e-14  6.39743e-14
 6.03227e-11  2.42905e-11  8.13328e-11     9.1162e-15   3.67087e-15
 6.03227e-11  8.13328e-11  2.42905e-11     2.7226e-15   3.67087e-15
 1.15897e-11  4.6669e-12   4.6669e-12   …  5.2309e-16   2.10635e-16

julia&gt; K12^2  # example
4096×4096 KroneckerPower{KroneckerPower{Array{Float64,2},2},6}:
 0.000332987  0.000384178  0.000384178  …  0.00160543   0.00185224
 5.47445e-5   7.00943e-5   6.31607e-5      0.00026394   0.000337946
 5.47445e-5   6.31607e-5   7.00943e-5      0.000292915  0.000337946
 9.00025e-6   1.15238e-5   1.15238e-5      4.81566e-5   6.16592e-5
 5.47445e-5   6.31607e-5   6.31607e-5      0.000292915  0.000337946
 9.00025e-6   1.15238e-5   1.03839e-5   …  4.81566e-5   6.16592e-5
 9.00025e-6   1.03839e-5   1.15238e-5      5.34431e-5   6.16592e-5
 1.47968e-6   1.89457e-6   1.89457e-6      8.78629e-6   1.12499e-5
 5.47445e-5   6.31607e-5   6.31607e-5      0.000292915  0.000337946
 9.00025e-6   1.15238e-5   1.03839e-5      4.81566e-5   6.16592e-5
 ⋮                                      ⋱               ⋮
 7.89733e-13  1.01117e-12  1.01117e-12     1.07896e-11  1.38149e-11
 2.92181e-11  3.371e-11    3.371e-11       3.597e-10    4.14999e-10
 4.80359e-12  6.15047e-12  5.54207e-12     5.91364e-11  7.57176e-11
 4.80359e-12  5.54207e-12  6.15047e-12  …  6.56283e-11  7.57176e-11
 7.89733e-13  1.01117e-12  1.01117e-12     1.07896e-11  1.38149e-11
 4.80359e-12  5.54207e-12  5.54207e-12     6.56283e-11  7.57176e-11
 7.89733e-13  1.01117e-12  9.11142e-13     1.07896e-11  1.38149e-11
 7.89733e-13  9.11142e-13  1.01117e-12     1.1974e-11   1.38149e-11
 1.29836e-13  1.6624e-13   1.6624e-13   …  1.96859e-12  2.52056e-12</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Kronecker.kronecker-Tuple{AbstractArray{T,2} where T,Int64}" href="#Kronecker.kronecker-Tuple{AbstractArray{T,2} where T,Int64}"><code>Kronecker.kronecker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">kronecker(A::AbstractMatrix, pow::Int)</code></pre><p>Kronecker power, computes <code>A ⊗ A ⊗ ... ⊗ A</code>. Returns a lazy <code>KroneckerPower</code> type.</p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>⊗(A::AbstractMatrix, pow::Int)</code>. Check Documenter&#39;s build log for details.</p></div></div><h2><a class="nav-anchor" id="Kronecker-graphs-1" href="#Kronecker-graphs-1">Kronecker graphs</a></h2><p>An exciting application of Kronecker powers (or Krocker products in general) is generating large, realistic graphs from an initial &#39;seed&#39; via a stochastic process. This is called a Kronecker graph and is described in detail in <a href="https://cs.stanford.edu/~jure/pubs/kronecker-jmlr10.pdf">Leskovec et al. (2008)</a>.</p><p>If we use an initial matrix <span>$P$</span> with values in <span>$[0,1]$</span> as a seed, then <span>$P_n=P^{\otimes n}$</span> can be seen as a probability distribution for an adjacency matrix of a graph. The elements <span>$(P_n)_{i,j}$</span> give the probabilities that there is an edge from node <span>$i$</span> to node <span>$j$</span>. Leskovec and co-authors give two algorithms for sampling adjacency matrices from this distribution, both provided by <code>Kronecker.jl</code>:</p><ul><li><code>naivesample</code> gives exact samples, but has a computational time proportional to the number of elements and hence prohibitive for large graphs;</li><li><code>fastsample</code> a recursive heuristic, has a computational time proportional to the expected number of edges in the graph.</li></ul><p>The latter can easily scale to generate graphs of millions of nodes. Both return the adjacency matrix as a sparse array.</p><pre><code class="language-julia-repl">julia&gt; using Kronecker

julia&gt; P = rand(2, 2)
2×2 Array{Float64,2}:
 0.828559  0.76686
 0.103496  0.849499

julia&gt; P10 = P ⊗ 10
1024×1024 KroneckerPower{Array{Float64,2},10}:
 0.152487     0.141132    0.141132    …  0.075992    0.075992    0.0703332
 0.0190473    0.156341    0.0176289      0.0841811   0.00949223  0.0779126
 0.0190473    0.0176289   0.156341       0.00949223  0.0841811   0.0779126
 0.00237921   0.0195287   0.0195287      0.0105151   0.0105151   0.0863087
 0.0190473    0.0176289   0.0176289      0.0841811   0.0841811   0.0779126
 0.00237921   0.0195287   0.00220205  …  0.0932528   0.0105151   0.0863087
 0.00237921   0.00220205  0.0195287      0.0105151   0.0932528   0.0863087
 0.00029719   0.00243935  0.00243935     0.0116483   0.0116483   0.0956096
 0.0190473    0.0176289   0.0176289      0.0841811   0.0841811   0.0779126
 0.00237921   0.0195287   0.00220205     0.0932528   0.0105151   0.0863087
 ⋮                                    ⋱
 1.12885e-9   9.26566e-9  9.26566e-9  …  0.021525    0.021525    0.176678
 7.23496e-8   6.69621e-8  6.69621e-8     0.155559    0.155559    0.143976
 9.03726e-9   7.41781e-8  8.3643e-9      0.172323    0.0194311   0.159491
 9.03726e-9   8.3643e-9   7.41781e-8     0.0194311   0.172323    0.159491
 1.12885e-9   9.26566e-9  9.26566e-9     0.021525    0.021525    0.176678
 9.03726e-9   8.3643e-9   8.3643e-9   …  0.172323    0.172323    0.159491
 1.12885e-9   9.26566e-9  1.04479e-9     0.190893    0.021525    0.176678
 1.12885e-9   1.04479e-9  9.26566e-9     0.021525    0.190893    0.176678
 1.41006e-10  1.15738e-9  1.15738e-9     0.0238446   0.0238446   0.195717

julia&gt; sum(P10)  # expected number of edges
11553.127812751693

julia&gt; A = fastsample(P10)
1024×1024 SparseArrays.SparseMatrixCSC{Bool,Int64} with 11055 stored entries:
  [5   ,    5]  =  true
  [5   ,    6]  =  true
  [6   ,    6]  =  true
  [33  ,    6]  =  true
  [165 ,    6]  =  true
  [5   ,    7]  =  true
  [263 ,    7]  =  true
  [517 ,    7]  =  true
  [3   ,    8]  =  true
  ⋮
  [986 , 1024]  =  true
  [988 , 1024]  =  true
  [999 , 1024]  =  true
  [1001, 1024]  =  true
  [1007, 1024]  =  true
  [1012, 1024]  =  true
  [1015, 1024]  =  true
  [1019, 1024]  =  true
  [1023, 1024]  =  true</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Kronecker.isprob" href="#Kronecker.isprob"><code>Kronecker.isprob</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isprob(A::AbstractArray)</code></pre><p>Test if a matrix can be interpeted as a probability matrix, i.e., all elements are between 0 and 1.</p></div></div><div><div><pre><code class="language-none">isprob(K::AbstractKroneckerProduct)</code></pre><p>Test if a Kronecker product can be interpeted as a probability matrix, i.e., all elements are between 0 and 1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Kronecker.naivesample" href="#Kronecker.naivesample"><code>Kronecker.naivesample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">naivesample(P::AbstractKroneckerProduct)</code></pre><p>Sample a Kronecker graph from a probabilistic Kronecker product P using the naive method. This method has a time complexity in the size of the Kronecker product (but is still light in memory use). Consider using <code>fastsample</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Kronecker.fastsample" href="#Kronecker.fastsample"><code>Kronecker.fastsample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fastsample(P::AbstractKroneckerProduct)</code></pre><p>Uses the heuristic sampling from Leskovec et al. (2008) to sample a large Kronecker graph.</p></div></div></section><footer><hr/><a class="previous" href="../indexed/"><span class="direction">Previous</span><span class="title">Indexed Kronecker products</span></a><a class="next" href="../kroneckersums/"><span class="direction">Next</span><span class="title">Kronecker sums</span></a></footer></article></body></html>
